\section{Loop invariants}
ในงานด้านวิศวกรรมคอมพิวเตอร์นั้น การเขียนโปรแกรมเป็นสิ่งที่หลีกเลี่ยงไม่ได้ \enskip แต่เมื่อเราเขียนโปรแกรมแล้ว เราจะมั่นใจได้อย่างไรว่าโปรแกรมที่เขียนขึ้นมานั้นทำงานได้ถูกต้องตามความต้องการ

\begin{example}\label{ex:prog-sum}
โปรแกรมพื้นฐานต่อไปนี้ใช้หาผลรวมของเลขจำนวนเต็มตั้งแต่ $1$ ถึง $n$
\begin{lstlisting}[language=java]
int sum = 0;
for (int i = 1; i <= n; i++)
  sum += i;
\end{lstlisting}
แต่เราจะทราบได้อย่างไรว่า ผลลัพธ์สุดท้าย (\cd{sum}) ของโปรแกรมนี้จะเป็นค่าที่เราต้องการเสมอ กล่าวคือ จะมั่นใจได้อย่างไรว่า \cd{sum} จะเป็นผลรวมของเลขจำนวนเต็มตั้งแต่ $1$ ถึง $n$
\end{example}

\begin{example}\label{ex:prog-insertion-sort}
โปรแกรมต่อไปนี้เรียงลำดับสมาชิกใน array จากน้อยไปมาก
\begin{lstlisting}[language=java]
int[] a = ...;
int n = a.length;
for (int i = 1; i < n; i++) {
  int x = a[i];
  int j = i;
  for (; j > 0 && a[j-1] > x; j--)
    a[j] = a[j-1];
  a[j] = x;
}
\end{lstlisting}
หากเราได้เรียนรู้วิธีการเรียงลำดับแบบต่างๆ มาก่อน เราจะเห็นทันทีว่าโปรแกรมข้างต้นนั้นเป็นการเรียงลำดับแบบ \emph{insertion sort} \enskip แต่ถ้าเราไม่เคยเห็นโปรแกรมที่เขียนในลักษณะนี้มาก่อน จะแน่ใจได้อย่างไรว่าสมาชิกใน array ที่ผ่านโปรแกรมนี้มาแล้วจะเรียงลำดับจากน้อยไปมาก \enskip หากจะกล่าวให้กว้างขึ้น เราจะมั่นใจได้อย่างไรว่าโปรแกรมที่เราไม่เคยเห็นมาก่อน แต่ถูกอ้างว่าเป็นโปรแกรมที่สามารถเรียงลำดับสมาชิกใน array ได้นั้นจะทำงานได้ถูกต้องจริงๆ
\end{example}

โดยทั่วไปแล้ว โปรแกรมส่วนใหญ่มักจะใช้\emph{วงวน} (loop) ในการทำงาน \enskip หากเราสามารถให้เหตุผลในการอธิบายการทำงานของ loops ต่างๆ ในโปรแกรมได้ จะทำให้เราสามารถสรุปได้ว่าโปรแกรมที่เรากำลังพิจารณาอยู่นั้นทำงานได้ถูกต้องตามความต้องการหรือไม่ \enskip การให้เหตุผลในการทำงานของ loop นั้นสามารถทำได้โดยการเขียนประพจน์หนึ่งๆ ที่จะเป็นจริงตลอดเวลา ไม่ว่า loop จะทำงานไปแล้วกี่ครั้งก็ตาม

\begin{definition}
\emph{ตัวยืนยงของวงวน} (loop invariant) เป็นประพจน์ที่เป็นจริงเสมอ ทั้งก่อน ระหว่าง และหลังการทำงานของ loop
\end{definition}
%
\begin{example}\label{ex:prog-sum-inv}
จาก Example~\ref{ex:prog-sum} เราสามารถเขียน loop invariant ได้ว่า ก่อนการทำงานในแต่ละรอบของ loop ทั้ง $\cd{sum}=\sum_{k=1}^{\cd{i}-1}{k}$ และ $1\leq\cd{i}\leq\cd{n}+1$ เป็นจริงทั้งคู่
\end{example}

อย่างไรก็ดี loop invariants ที่เราเขียนนั้นย่อมไม่มีประโยชน์ หากเราไม่สามารถแสดงได้ว่าเป็นจริงดังอ้าง \enskip ดังนั้น เราจึงจำเป็นต้องตรวจสอบว่า loop invariants เป็นจริง โดยมีขั้นตอนหลักๆ ดังนี้
\begin{enumerate}
\item การตั้งต้น (establishment/initialization): แสดงว่า loop invariant เป็นจริงก่อนที่ loop จะเริ่มทำงาน
\item การสงวนรักษา (preservation/maintenance): แสดงว่า loop invariant เป็นจริงหลังจากจบการทำงานในแต่ละรอบของ loop
\item การตรวจสอบเงื่อนไขหลังการทำงาน (postcondition): แสดงว่า loop จะให้ผลลัพธ์ตามที่เราต้องการหากเราสมมุติว่า loop จบการทำงาน
\item การจบการทำงาน (termination): แสดงว่า loop จะจบการทำงานเสมอ
\end{enumerate}
เราจะใช้ Example~\ref{ex:prog-sum-inv} ในการสาธิตการให้เหตุผลในแต่ละขั้นตอนข้างต้น

\subsection{Establishment}
ในขั้นตอนนี้ เราต้องแสดงว่า loop invariant เป็นจริงหลังจากกำหนดค่าตั้งต้นของ loop แล้ว แต่ก่อนที่ loop จะเริ่มทำงาน \enskip ในตัวอย่างโปรแกรมที่กำลังพิจารณานั้น จุดที่เราจะพิจารณาคือหลังจากการกำหนดค่าตั้งต้น \cd{i=1} ใน \lstinline[language=Java]{for} loop แล้ว

จากโปรแกรมตัวอย่าง ก่อน loop ทำงานครั้งแรก จะได้ว่า $\cd{i}=1$ และ $\cd{sum}=0$ ดังนั้น
\[\sum_{k=1}^{\cd{i}-1}{k}=\sum_{k=1}^{1-1}{k}=\sum_{k=1}^{0}{k}=0=\cd{sum}\]
และ $1\leq\cd{i}\leq\cd{n}+1$ จึงสรุปได้ว่า loop invariant เป็นจริงก่อนการทำงานของ loop

\subsection{Preservation}
ในขั้นตอนนี้ เราต้องแสดงว่า หาก loop invariant เป็นจริงก่อนการทำงานของ loop ในรอบใดๆ แล้ว loop invariant จะยังเป็นจริงอยู่หลังจากจบการทำงานในรอบนั้นๆ ของ loop ซึ่งรวมไปถึงการปรับค่าต่างๆ เมื่อจบการทำงานในรอบนั้นๆ แล้วด้วย \enskip ในตัวอย่างโปรแกรมที่กำลังพิจารณาอยู่นั้น จุดที่เราจะพิจารณาคือหลังจากการเปลี่ยนค่า \cd{i} ด้วยคำสั่ง \cd{i++} ใน \lstinline[language=java]{for} loop แล้ว

จากโปรแกรมตัวอย่าง สมมุติว่า loop invariant เป็นจริงก่อนการทำงานในรอบถัดไป กล่าวคือ $\cd{i}\leq\cd{n}$ (เนื่องจาก loop จะทำงาน) และ
\[\cd{sum}=\sum_{k=1}^{\cd{i}-1}{k} \textup{\quad และ \quad} 1\leq\cd{i}\leq\cd{n}+1\]
เราต้องแสดงว่า หลัง loop จบการทำงานในรอบถัดไปนี้แล้ว loop invariant จะยังเป็นจริงดังเดิม โดยจะต้องพิจารณาค่าต่างๆ ที่เปลี่ยนไปเนื่องจากการทำงานของแต่ละคำสั่งใน loop

ก่อนอื่น เนื่องจากเราทราบว่า $\cd{i}\leq\cd{n}$ และ $1\leq\cd{i}\leq\cd{n}+1$ จะได้ว่า $1\leq\cd{i}\leq\cd{n}$ ก่อนการทำงานของ loop ในรอบนี้

เมื่อทำคำสั่ง \cd{sum += i} ค่าของ \cd{sum} จะเปลี่ยนเป็น $\cd{sum}'$ โดยที่
\[\cd{sum}'=\cd{sum}+\cd{i}=\left[\sum_{k=1}^{\cd{i}-1}{k}\right]+\cd{i}=\sum_{k=1}^{\cd{i}}{k}\]
จากนั้น เมื่อคำสั่ง \cd{i++} ทำงาน ค่าของ \cd{i} จะเปลี่ยนเป็น $\cd{i}'=\cd{i}+1$ กล่าวคือ $\cd{i}=\cd{i}'-1$ \enskip ดังนั้น หลังจบการทำงานของ loop ในรอบนี้ ค่าของ \cd{sum}, \cd{i}, และ \cd{n} จะเปลี่ยนไปเป็น $\cd{sum}', \cd{i}', \cd{n}'$ ตามลำดับ โดยที่ $\cd{n}'=\cd{n}$ (กล่าวคือ \cd{n} นั้นไม่เปลี่ยนค่า) และค่าอื่นๆ เป็นไปดังก่อนหน้านี้ \enskip จะได้ว่า
\[\cd{sum}'=\sum_{k=1}^{\cd{i}}{k}=\sum_{k=1}^{\cd{i}'-1}{k}\]
นอกจากนี้ เนื่องจาก $1\leq\cd{i}\leq\cd{n}$ จะได้ว่า $1\leq\cd{i}+1\leq\cd{n}+1$ กล่าวคือ $1\leq\cd{i}'\leq\cd{n}'+1$ \enskip จึงสรุปได้ว่า loop invariant นั้นยังคงเป็นจริงหลังจากการทำงานของ loop ในรอบที่ผ่านมา

ในลำดับการให้เหตุผลข้างต้น ชื่อตัวแปรต่างๆ นั้นจะเปลี่ยนแปลงเล็กน้อยเมื่อมีการเปลี่ยนแปลงค่า เพื่อป้องกันความสับสนที่อาจจะเกิดขึ้นหากตัวแปรแต่ละตัวสามารถเป็นได้หลายค่า ตัวอย่างเช่น ค่าของตัวแปร \cd{sum} นั้นเป็นค่าหนึ่งก่อนที่ loop จะเริ่มการทำงาน แต่เปลี่ยนเป็นอีกค่าหนึ่งเมื่อ loop จบการทำงาน ด้วยเหตุนี้ ชื่อของตัวแปรดังกล่าวจึงเปลี่ยนเป็น $\cd{sum}'$ เพื่อป้องกันความสับสนว่า ณ ขณะหนึ่งๆ เรากำลังกล่าวถึงตัวแปรในขั้นตอนใดของ loop \enskip อย่างไรก็ดี จะเห็นว่า เมื่อ loop จบการทำงานแล้ว ค่าสุดท้ายของแต่ละตัวแปรก็ยังคงทำให้ loop invariant เป็นจริงเช่นเดิม

นอกจากนี้ สังเกตว่า ในขั้นตอน establishment และ preservation นั้น วิธีการให้เหตุผลจะมีความใกล้เคียงกับการพิสูจน์โดยอุปนัย \enskip โดยขั้นตอน establishment นั้นเทียบเคียงได้กับ base case และขั้นตอน preservation นั้นเทียบเคียงได้กับ inductive step \enskip จะเห็นว่า เมื่อเราให้เหตุผลในสองขั้นตอนนี้เรียบร้อยแล้ว เราสามารถสรุปได้ว่า ไม่ว่า loop จะทำงานไปกี่รอบก็ตาม loop invariant ก็จะยังเป็นจริงไม่เปลี่ยนแปลง

\subsection{Postcondition}
ในขั้นตอนนี้ เราต้องแสดงว่า หาก loop invariant เป็นจริง แต่ loop นั้นไม่ทำงานในรอบต่อไปเนื่องจากเงื่อนไขควบคุม (loop guard) กลายเป็นเท็จ แล้ว loop invariant จะให้ผลลัพธ์จากการทำงานของโปรแกรมที่เราคาดหวังไว้ \enskip ในตัวอย่างโปรแกรมที่กำลังพิจารณาอยู่นั้น ผลลัพธ์ที่เราต้องการก็คือ ค่าของตัวแปร \cd{sum} ต้องเป็นผลรวมของเลขจำนวนเต็มตั้งแต่ $1$ ถึง $n$

จากโปรแกรมตัวอย่าง สมมุติว่า loop invariant เป็นจริง กล่าวคือ
\[\cd{sum}=\sum_{k=1}^{\cd{i}-1}{k} \textup{\quad และ \quad} 1\leq\cd{i}\leq\cd{n}+1\]
แต่ loop นั้นไม่ทำงานในรอบต่อไป แสดงว่า loop guard (\cd{i <= n}) นั้นเป็นเท็จ กล่าวคือ $\cd{i}>\cd{n}$ \enskip แต่เนื่องจากเราทราบว่า $1\leq\cd{i}\leq\cd{n}+1$ จึงสรุปได้ว่า ค่าของตัวแปร $\cd{i}$ นั้นเป็นได้เพียง $\cd{n}+1$ เท่านั้น \enskip หากเรานำค่านี้ไปแทนใน loop invariant ที่กล่าวถึงตัวแปร \cd{sum} จะได้ว่า
\[\cd{sum}=\sum_{k=1}^{(\cd{n}+1))-1}{k}=\sum_{k=1}^{\cd{n}}{k}\]
ซึ่งเป็นผลลัพธ์ที่เราต้องการจากการทำงานของโปรแกรม

สังเกตว่า ขั้นตอนนี้ไม่ได้แสดงว่า loop จะจบการทำงาน แต่แสดงเพียงว่า \emph{หาก} loop จบการทำงาน แล้วผลลัพธ์ที่ได้จะเป็นไปตามที่เราต้องการ \enskip ในขั้นตอนถัดไป เราจะแสดงว่า loop นั้นจบการทำงานเสมอ ซึ่งเมื่อนำผลดังกล่าวมารวมกับขั้นตอนนี้ จะทำให้เราสรุปได้ว่า loop นั้นให้ผลลัพธ์ที่ถูกต้องเสมอ

\subsection{Termination}
ในขั้นตอนสุดท้าย เราต้องแสดงว่า หาก loop invariant เป็นจริงก่อนการทำงานในแต่ละรอบของ loop แล้วในท้ายที่สุด loop ต้องจบการทำงาน โดยกำหนดค่าค่าหนึ่งที่ขึ้นกับตัวแปรต่างๆ ที่ปรากฏใน loop invariant (เรียกค่านี้ว่า $d$) ซึ่งจะใช้บ่งชี้เวลาที่ loop นี้ยังมีเหลืออยู่ในการทำงาน กล่าวคือ ค่านี้ต้องลดลงหลังแต่ละรอบของ loop จบการทำงาน และค่านี้จะลดลงไปตลอดกาลไม่ได้ นั่นคือ ต้องมีค่าคงที่ $d_0$ ที่หาก $d<d_0$ เมื่อใดแล้ว loop guard จะต้องเป็นเท็จ (ซึ่งทำให้ loop จบการทำงาน ไม่เป็น infinite loop)

จากโปรแกรมตัวอย่าง พิจารณาค่าของ $d\triangleq\cd{n}-\cd{i}$ \enskip เนื่องจากในแต่ละรอบของ loop ค่าของ \cd{i} เมื่อจบการทำงานคือ $\cd{i}'=\cd{i}+1$ ดังนั้น $d'=\cd{n}'-\cd{i}'=\cd{n}-i-1<\cd{n}-\cd{i}=d$ กล่าวคือ ค่านี้จะลดลงเสมอหลังการทำงานแต่ละรอบของ loop \enskip นอกจากนี้ พิจารณา $d_0\triangleq 0$ \enskip จะเห็นว่า $\cd{n}-\cd{i}\geq 0$ (นั่นคือ $d\geq d_0$) เสมอ มิฉะนั้น หาก $\cd{n}-\cd{i}<0$ กล่าวคือ $\cd{i}>\cd{n}$ แล้ว loop guard จะต้องเป็นเท็จ ซึ่งแปลว่า loop ดังกล่าวจะจบการทำงานนั่นเอง

\begin{example}
ในตัวอย่างนี้ เราจะทำการพิสูจน์ความถูกต้องของ insertion sort ใน Example~\ref{ex:prog-insertion-sort} \enskip ก่อนอื่น เนื่องจากโปรแกรมนี้ประกอบไปด้วย loop สองชั้น เราจึงต้องหา loop invariant สำหรับแต่ละ loop ก่อน ดังนี้

สำหรับ loop นอกนั้น ก่อนการทำงานแต่ละรอบของ loop จะได้ว่า
\begin{itemize}
\item $1\leq\cd{i}\leq\cd{n}$
\item $\cd{a}[0..\cd{i}-1]$ มีสมาชิกเช่นเดียวกับ $\cd{a}[0..\cd{i}-1]$ ก่อนเริ่มการทำงานของ loop แต่จะเรียงลำดับจากน้อยไปมาก (sorted)
\end{itemize}

สำหรับ loop ในนั้น ก่อนการทำงานแต่ละรอบของ loop จะได้ว่า
\begin{itemize}
\item $0\leq\cd{j}\leq\cd{i}$
\item $\forall k\in[\cd{j}..\cd{i}]: \cd{a}[k]\geq\cd{x}$
\item $\cd{a}[0..\cd{j}-1]$ มีสมาชิกเช่นเดียวกับ $\cd{a}[0..\cd{j}-1]$ ก่อนเริ่มการทำงานของ loop แต่จะเรียงลำดับจากน้อยไปมาก (sorted)
\item $\cd{a}[\cd{j}+1..\cd{i}]$ มีสมาชิกเช่นเดียวกับ $\cd{a}[\cd{j}..\cd{i}-1]$ ก่อนเริ่มการทำงานของ loop แต่จะเรียงลำดับจากน้อยไปมาก (sorted)
\end{itemize}

ข้อสังเกตที่สำคัญในขั้นตอนนี้คือ การหา loop invariant นั้นโดยปกติแล้วไม่ใช่กระบวนการที่ง่ายดาย แต่อาจจะต้องลองผิดลองถูกเพื่อค้นหาข้อมูลที่เพียงพอที่จะทำให้เราสามารถสรุปได้ว่าการทำงานของ loop จะยังทำให้คุณสมบัติที่เราค้นหามานั้นเป็นจริงดังเดิม \enskip ทั้งนี้ การทดลองว่า loop invariant ที่เราตั้งขึ้นมานั้นเพียงพอต่อการพิสูจน์หรือไม่ ก็คือการลองเขียนบทพิสูจน์ตามกระบวนการทั้ง 4 ขั้นตอนข้างต้น แล้วพิจารณาว่ามีส่วนใดที่ขาดหายไปหรือไม่ \enskip หากมี เราสามารถเพิ่มเข้าไปใน loop invariant ที่เราพยายามจะแสดง จนกว่าการให้เหตุผลของเราจะสำเร็จลุล่วง

ในลำดับถัดไป จะแสดงว่า loop invariant สำหรับ loop นอกนั้นเป็นจริง
\begin{itemize}
\item {\bf Establishment}: เริ่มแรก $\cd{i}=1$ ดังนั้น $1\leq\cd{i}\leq\cd{n}$ \enskip นอกจากนี้ $\cd{a}[0..1-1]=\cd{a}[0]$ นั้นเรียงตามลำดับ เนื่องจากมีสมาชิกเพียงตัวเดียว \qquad\yea

\item {\bf Preservation}: สมมุติว่า $1\leq\cd{i}\leq\cd{n}$ และ $\cd{a}[0..\cd{i}-1]$ sorted และให้ loop ทำงานในรอบต่อไป กล่าวคือ $\cd{i}<\cd{n}$ \enskip ดังนั้น $1\leq\cd{i}<\cd{n}$

เมื่อ inner loop จบการทำงาน loop invariant ของ inner loop นั้นกล่าวว่า ค่าสุดท้ายของ $\cd{j}$ จะต้องมีคุณสมบัติดังนี้ $0\leq\cd{j}\leq\cd{i}$ และ $\forall k\in[\cd{j}..\cd{i}]: \cd{a}[k]\geq\cd{x}$ \enskip นอกจากนี้ $\cd{a}[0..\cd{j}-1]$ และ $\cd{a}[\cd{j}+1..\cd{i}]$ ยัง sorted โดยที่สมาชิกใน $\cd{a}[\cd{j}+1..\cd{i}]$ นั้นเป็นเช่นเดียวกับสมาชิกของ $\cd{a}[\cd{j}..\cd{i}-1]$ ก่อนการทำงานของ inner loop อีกด้วย

เนื่องจาก inner loop จบการทำงาน แสดงว่า inner loop guard (\cd{j > 0 && a[j-1] > x}) ต้องเป็นเท็จ กล่าวคือ $\cd{j}\leq 0\vee\cd{a}[\cd{j}-1]\leq\cd{x}$ ต้องเป็นจริง \enskip แยกกรณีดังนี้
\begin{itemize}
\item $\cd{j}\leq 0$: เนื่องจาก $0\leq\cd{j}\leq\cd{i}$ จะได้ว่า $\cd{j}=0$ กล่าวคือ $\cd{a}[1..\cd{i}]$ sorted และมีสมาชิกเช่นเดียวกับ $\cd{a}[0..\cd{i}-1]$ ก่อนการทำงานของ loop \enskip นอกจากนี้ เนื่องจากเราทราบว่า $\forall k\in[0..\cd{i}]: \cd{a}[k]\geq\cd{x}$ กล่าวคือ สมาชิก $\cd{i}+1$ ตัวแรกของ \cd{a} นั้นมีค่าไม่น้อยกว่า $\cd{x}$ ทั้งสิ้น เมื่อทำคำสั่ง \cd{a[j] = x} (นั่นคือ \cd{a[0] = x}) จะได้ว่า $\cd{a}[0..\cd{i}]$ sorted และมีสมาชิกเช่นเดียวกับ $\cd{a}[0..\cd{i}]$ ก่อนการทำงานของ loop ด้วย \enskip ดังนั้น เมื่อกำหนดค่าในช่องแรกของ \cd{a} ให้เป็น \cd{x} จะได้ว่าสมาชิก $\cd{i}+1$ ตัวแรกของ \cd{a} ก็ยังคงเรียงลำดับเหมือนเดิม

\item $\cd{a}[\cd{j}-1]\leq\cd{x}$: เนื่องจาก $\cd{a}[0..\cd{j}-1]$ และ $\cd{a}[\cd{j}+1..\cd{i}]$ นั้น sorted จะได้ว่า $\forall k<\cd{j}: \cd{a}[k]\leq x$ กล่าวคือ ทุกช่องของ \cd{a} ทางด้านซ้ายของตำแหน่ง \cd{j}    จะมีค่าไม่เกิน \cd{x} และ $\forall k\in[\cd{j}..\cd{i}]: \cd{a}[k]\geq x$ กล่าวคือ ทุกช่องของ \cd{a} ทางด้านขวาของตำแหน่ง \cd{j} แต่ไม่เกินตำแหน่ง \cd{i} จะมีค่าไม่น้อยกว่า \cd{x} \enskip หากเขียนเป็นแผนภาพ จะได้ดังนี้
\begin{center}
\begin{tikzpicture}
\node[draw] (left) [minimum height=2ex,minimum width=4cm] {};
\node[below=0in of left.south west] {0};
\node[below=0in of left.south] {\small $\leq\cd{x}$, sorted};
\node[below=0in of left.south east] {$\cd{j}-1$};

\node[draw,right=1.5cm of left] (mid) [minimum height=2ex,minimum width=1em] {};
\node[below=0in of mid.south] {$\cd{j}$};

\node[draw,right=1.5cm of mid] (right) [minimum height=2ex,minimum width=4cm] {};
\node[below=0in of right.south west] {$\cd{j}+1$};
\node[below=0in of right.south] {\small $\geq\cd{x}$, sorted};
\node[below=0in of right.south east] {\cd{i}};
\end{tikzpicture}
\end{center}
เมื่อทำคำสั่ง \cd{a[j] = x} จะได้ว่า $\cd{a}[0..\cd{i}]$ sorted และมีสมาชิกเช่นเดียวกับ $\cd{a}[0..\cd{i}]$ ก่อนการทำงานของ loop
\end{itemize}
ดังนั้น ไม่ว่าในกรณีใดๆ จะได้ว่า $\cd{a}[0..\cd{i}]$ จะมีสมาชิกเช่นเดิม แต่เรียงลำดับเสมอ \enskip นอกจากนี้ เมื่อเพิ่มค่า \cd{i} ในคำสั่ง \cd{i++} จะได้ว่า $\cd{i}'=\cd{i}+1$ \enskip ดังนั้น $\cd{a}[0..\cd{i}'-1]$ นั้น sorted และเนื่องจาก $1\leq\cd{i}<\cd{n}$ จะได้ว่า $1\leq\cd{i}+1\leq\cd{n}$ กล่าวคือ $1\leq\cd{i}'\leq\cd{n}$ นั่นเอง ซึ่งแปลว่า loop invariant ยังคงเป็นจริงหลังการทำงานของ outer loop ในรอบนี้ \qquad\yea

\item {\bf Postcondition}: สมมุติว่า loop invariant เป็นจริง แต่ loop ไม่ทำงานในรอบต่อไป แสดงว่า loop guard (\cd{i < n}) เป็นเท็จ นั่นคือ $\cd{i}\geq\cd{n}$ \enskip แต่เนื่องจาก loop invariant เป็นจริง แสดงว่า $1\leq\cd{i}\leq\cd{n}$ \enskip ดังนั้น ค่าเดียวของ \cd{i} ที่เป็นไปได้คือ $\cd{i}=\cd{n}$ \enskip และจาก loop invariant เราทราบด้วยว่า $\cd{a}[0..\cd{i}-1]$ นั้น sorted จะได้ว่า $\cd{a}[0..\cd{n}-1]$ นั้น sorted กล่าวคือ array ที่เรามีอยู่นั้นเรียงลำดับได้ถูกต้องนั่นเอง \qquad\yea

\item {\bf Termination}: พิจารณา $d\triangleq\cd{n}-\cd{i}$ และ $d_0\triangleq 1$ \enskip เนื่องจากในแต่ละรอบ $\cd{i}'=\cd{i}+1$ แสดงว่า $\cd{n}'-\cd{i}'=\cd{n}-\cd{i}-1<\cd{n}-\cd{i}$ กล่าวคือ ค่าของ $d$ นั้นจะลดลงในแต่ละรอบ \enskip นอกจากนี้ $\cd{n}-\cd{i}\geq 1$ เสมอ \enskip หาก $\cd{n}-\cd{i}<1$ แสดงว่า $\cd{i}+1>\cd{n}$ กล่าวคือ $\cd{i}\geq\cd{n}$ ซึ่งจะทำให้ outer loop guard เป็นเท็จ \enskip ดังนั้น insertion sort จะจบการทำงานเสมอ \qquad\yea
\end{itemize}

ในลำดับสุดท้าย จะแสดงว่า loop invariant สำหรับ loop ในนั้นเป็นจริง
\begin{itemize}
\item {\bf Establishment}: เริ่มแรก $\cd{j}=\cd{i}$ ดังนั้น $0\leq\cd{j}\leq\cd{i}$ และเนื่องจาก outer loop invariant เป็นจริง $\cd{a}[0..\cd{i}-1]$ sorted ซึ่งแปลว่า $\cd{a}[0..\cd{j}-1]$ sorted \enskip นอกจากนี้ $\forall k\in[\cd{j}..\cd{i}]: \cd{a}[k]\geq\cd{x}$ นั้นเป็นจริง เนื่องจากมีค่า $k$ เพียงค่าเดียวที่เป็นไปได้ กล่าวคือ $k=\cd{j}=\cd{i}$ และ $\cd{x}=\cd{a}[\cd{i}]$ ตามคำสั่งที่ประมวลผลก่อน inner loop จะทำงาน \enskip ในท้ายที่สุด $\cd{a}[\cd{j}+1..\cd{i}]$ นั้นไม่มีสมาชิกอยู่เลย จึงเรียงลำดับโดยปริยาย \enskip จึงสรุปได้ว่า inner loop invariant เป็นจริงก่อนการทำงานของ inner loop \qquad\yea

\item {\bf Preservation}: สมมุติว่า inner loop invariant เป็นจริง และ inner loop ทำงาน จะได้ว่า $0<\cd{j}\leq\cd{i}$ และ $\cd{a}[\cd{j}-1]>\cd{x}$ \enskip เมื่อทำคำสั่ง \cd{a[j] = a[j-1]} จะได้ว่า สมาชิกใน $\cd{a}[\cd{j}..\cd{i}]$ นั้นเป็นเช่นเดียวกับ $\cd{a}[\cd{j}-1..\cd{i}-1]$ ก่อนการทำงานของ inner loop (เนื่องจากเราทราบก่อนหน้านี้ว่า สมาชิกใน $\cd{a}[\cd{j}+1..\cd{i}]$ นั้นเป็นเช่นเดียวกับ $\cd{a}[\cd{j}..\cd{i}-1]$) \enskip นอกจากนี้ $\cd{a}[0..\cd{j}-2]$ sorted (เนื่องจากเราทราบก่อนหน้านี้ว่า $\cd{a}[0..\cd{j}-1]$ sorted) และเนื่องจากก่อนหน้านี้ เราทราบว่า $\forall k\in[\cd{j}..\cd{i}]: \cd{a}[k]\geq\cd{x}$ และ $\cd{a}[\cd{j}-1]>\cd{x}$ (จากเงื่อนไขการทำงานของ loop) จะได้ว่า $\forall k\in[\cd{j}-1..\cd{i}]: \cd{a}[k]\geq\cd{x}$

เมื่อลดค่า \cd{j} ในคำสั่ง \cd{j--} จะได้ว่า $\cd{j}'=\cd{j}-1$ กล่าวคือ $\cd{j}=\cd{j}'+1$ \enskip ดังนั้น เมื่อแทนค่าใน predicates ต่างๆ ข้างต้น จะได้ว่า
\begin{itemize}
\item สมาชิกใน $\cd{a}[\cd{j}'+1..\cd{i}]$ นั้นเป็นเช่นเดียวกับ $\cd{a}[\cd{j}'..\cd{i}-1]$ ก่อนการทำงานของ inner loop
\item $\cd{a}[0..\cd{j}'-1]$ sorted
\item $\forall k\in[\cd{j}'..\cd{i}]: \cd{a}[k]\geq\cd{x}$
\end{itemize}
และเนื่องจาก $0<\cd{j}\leq\cd{i}$ จะได้ว่า $0\leq\cd{j}-1\leq\cd{i}$ กล่าวคือ $0\leq\cd{j}'\leq\cd{i}$ นั่นเอง \enskip ดังนั้น inner loop invariant จึงยังคงเป็นจริงหลังการทำงานของ inner loop \qquad\yea

\item {\bf Postcondition}: สมมุติว่า inner loop invariant เป็นจริง แต่ inner loop ไม่ทำงานในรอบต่อไป แสดงว่า inner loop guard (\cd{j > 0 && a[j-1] > x}) เป็นเท็จ กล่าวคือ $\cd{j}\leq 0\vee\cd{a}[\cd{j}-1]\leq\cd{x}$ เป็นจริง ซึ่งผลลัพธ์ที่ได้นั้นถูกนำไปใช้ในการให้เหตุผลในขั้นตอน preservation ของ outer loop ข้างต้นได้อย่างถูกต้อง จึงสรุปได้ว่า inner loop ทำงานได้ตามที่ต้องการหากจบการทำงาน \qquad\yea

\item {\bf Termination}: พิจารณา $d\triangleq\cd{j}$ และ $d_0\triangleq 1$ \enskip เนื่องจากในแต่ละรอบ $\cd{j}'=\cd{j}-1$ แสดงว่า 
\[d'=\cd{j}'=\cd{j}-1<\cd{j}=d\]
กล่าวคือ ค่าของ $d$ นั้นจะลดลงในแต่ละรอบ \enskip นอกจากนี้ $\cd{j}\geq 1$ เสมอ \enskip หาก $\cd{j}<1$ แสดงว่า $\cd{j}\leq 0$ ซึ่งจะทำให้ inner loop guard เป็นเท็จ \enskip ดังนั้น inner loop จะจบการทำงานเสมอ \qquad\yea
\end{itemize}
\end{example}
จากตัวอย่างข้างต้น จะเห็นว่า การให้เหตุผลในขั้นตอน preservation นั้นจะซับซ้อนกว่าในขั้นตอนอื่นๆ และจะเห็นว่า หากมี loops ที่ซ้อนกันอยู่ การแสดงว่า invariant ของ outer loop นั้นถูกต้องนั้นจำเป็นจะต้องใช้ invariant ของ inner loop ด้วย \enskip ในทางกลับกัน การแสดงว่า invariant ของ inner loop นั้นถูกต้องก็จำเป็นต้องใช้ invariant ของ outer loop ที่ต้องสมมุติว่าเป็นจริงก่อนการทำงานของ inner loop \enskip ดังนั้น เราจึงต้องทำการพิสูจน์ invariants ของทั้งสอง loops ไปพร้อมๆ กัน ดังที่ได้สาธิต
