\section{Stars and bars}
\begin{example}
มีขนม 10 ชิ้น ต้องการแจกให้คน 4 คนจนหมด โดยที่แต่ละคนได้ขนมอย่างน้อย 1 ชิ้น จะสามารถทำได้กี่วิธี

กระบวนการแบ่งขนมแบบหนึ่งที่ทำได้ คือการนำขนมทุกชิ้นมาเรียงกันเป็นแถว แล้วใช้ไม้คั่นระหว่างขนม โดยขนมที่อยู่ทางด้านซ้ายของไม้ชิ้นแรกจะเป็นของคนแรก ขนมที่อยู่ระหว่างไม้ชิ้นแรกและชิ้นที่สองจะเป็นของคนที่สอง เป็นแบบนี้ไปเรื่อยๆ ดังรูป
\begin{center}
\begin{tikzpicture}
\foreach \i in {1,2,...,10} {
  \node[circle,draw] at (\i,0) {};
}
\foreach \i in {2.5,5.5,9.5} {
  \draw (\i,-0.5) -- (\i,0.5);
}
\end{tikzpicture}
\end{center}
จากรูป จะได้ว่า คนแรกจะได้ขนมไป 2 ชิ้น คนที่สองได้ไป 3 ชิ้น คนที่สามได้ไป 4 ชิ้น และคนสุดท้ายได้ไป 1 ชิ้น

จะเห็นว่า การแบ่งขนมดังรูปข้างต้นนั้นเป็นเพียงวิธีเดียวที่เป็นไปได้ \enskip หากจะหาจำนวนวิธีทั้งหมดที่เป็นไปได้ จะต้องพิจารณาว่าเราสามารถวางไม้คั่นได้กี่อย่างไรบ้าง \enskip ในกรณีทั่วไป เราจำเป็นต้องวางไม้คั่นจำนวน 3 แท่งระหว่างขนม 2 ชิ้นใดๆ ที่ติดกัน \enskip เนื่องจากขนมมีทั้งสิ้น 10 ชิ้น จึงมีช่องว่างระหว่างขนม 2 ชิ้นที่ติดกันจำนวน 9 ช่อง ดังรูป
\begin{center}
\begin{tikzpicture}
\foreach \i in {1,2,...,10} {
  \node[circle,draw] at (\i,0) {};
}
\foreach \i in {1.5,2.5,...,9.5} {
  \draw[arrow] (\i,-0.75) -- (\i,-0.125);
}
\end{tikzpicture}
\end{center}
เนื่องจากมีช่องว่างระหว่างขนมให้เลือกวางไม้คั่นทั้งหมด 9 ตำแหน่ง และเราต้องเลือกมา 3 ตำแหน่งเพื่อวางไม้คั่น จะได้ว่า จำนวนวิธีแบ่งขนมทั้งหมดที่เป็นไปได้คือ $\binom{9}{3}$
\end{example}

ตัวอย่างข้างต้นเป็นแนวทางการพิสูจน์ทฤษฎีบทต่อไปนี้
\begin{theorem}
ให้ $n$ และ $k$ เป็นจำนวนเต็มบวก \enskip ลำดับที่มีความยาว $k$ ซึ่งสมาชิกแต่ละตัวในลำดับเป็นจำนวนเต็มบวก โดยที่ผลรวมของสมาชิกในลำดับนี้ต้องเท่ากับ $n$ มีจำนวนทั้งสิ้น $\binom{n-1}{k-1}$ ลำดับ
\end{theorem}
ทฤษฎีบทดังกล่าวได้รับการขนานนามว่า \emph{stars and bars} เนื่องจากเราสามารถใช้แผนภาพดังที่ได้นำเสนอไปในการช่วยพิสูจน์ความถูกต้อง \enskip ทั้งนี้ stars จากตัวอย่างข้างต้นคือขนม และ bars จากตัวอย่างข้างต้นคือไม้คั่น

\begin{example}
มีซาลาเปา 4 ไส้ ต้องการซื้อ 10 ลูก โดยต้องซื้อแต่ละไส้อย่างน้อย 1 ลูก จะสามารถทำได้กี่วิธี

จะเห็นว่า ปัญหานี้เป็นปัญหาเดียวกันกับตัวอย่างก่อนหน้านี้ แต่ในบริบทที่ต่างกัน \enskip ในตัวอย่างนี้ เราจะนำซาลาเปาทั้งหมดที่ยังไม่กำหนดไส้มาเรียงกันเป็นแถวก่อน \enskip จากนั้น นำไม้ 3 แท่งมาคั่นระหว่างซาลาเปาสองลูกใดๆ โดยซาลาเปาที่อยู่ทางด้านซ้ายของไม้ชิ้นแรกจะเป็นไส้แรก ซาลาเปาที่อยู่ระหว่างไม้ชิ้นแรกและชิ้นที่สองจะเป็นไส้ที่สอง เป็นแบบนี้ไปเรื่อยๆ \enskip ดังนั้น จำนวนวิธีซื้อซาลาเปาทั้งหมดที่เป็นไปได้ คือ $\binom{9}{3}$
\end{example}

\begin{example}
มีขนม 10 ชิ้น ต้องการแจกให้คน 4 คนจนหมด โดยที่แต่ละคนได้ขนมอย่างน้อย 2 ชิ้น จะสามารถทำได้กี่วิธี

จะเห็นว่า ปัญหานี้คล้ายกับปัญหาก่อนหน้านี้มาก เว้นเสียแต่ว่าแต่ละคนต้องได้ขนมอย่างน้อยสองชิ้น \enskip ในกรณีนี้ เราจะทำการแปลงปัญหานี้ให้เป็นปัญหาเดิมที่เราทราบวิธีการแก้ไข ดังนี้ \enskip เริ่มแรก เนื่องจากแต่ละคนต้องได้ขนมอย่างน้อย 2 ชิ้น จึงแจกขนมให้แต่ละคน คนละ 1 ชิ้นก่อน ทำให้เรายังเหลือขนมทั้งสิ้น 6 ชิ้นที่ยังต้องแจกจ่าย \enskip ดังนั้น ปัญหาข้างต้นจึงเทียบเท่ากับการแจกขนม 6 ชิ้น ให้คน 4 คน โดยที่แต่ละคนได้อย่างน้อย 1 ชิ้น ซึ่งสามารถทำได้ทั้งสิ้น $\binom{5}{3}$ วิธี
\end{example}

กระบวนการแปลงปัญหาข้างต้นนี้มีชื่อว่า \emph{reduction} ซึ่งเป็นการลดรูปปัญหาหนึ่งให้กลายเป็นอีกปัญหาหนึ่งที่เราทราบแนวทางการแก้ไขหรือให้เหตุผล \enskip Reductions นี้จะเป็นวิธีการสำคัญในการแก้ปัญหาหลายๆ แบบ รวมทั้งการให้เหตุผลเกี่ยวกับขั้นตอนวิธี (algorithms) ที่ใช้เวลานานในการทำงานด้วย ซึ่งอยู่นอกขอบเขตของวิชานี้

\begin{example}
มีซาลาเปา 4 ไส้ ต้องการซื้อ 10 ลูก โดยต้องซื้อแต่ละไส้อย่างน้อย 2 ลูก จะสามารถทำได้กี่วิธี

จะเห็นว่า ปัญหานี้คล้ายคลึงกับปัญหาในข้อที่แล้วเช่นเดียวกัน โดยเราสามารถซื้อซาลาเปาไส้ละ 1 ลูกมาก่อน ทำให้เราต้องซื้ออีก 6 ลูก ไส้ละอย่างน้อย 1 ลูก ซึ่งสามารถทำได้ $\binom{5}{3}$ วิธี
\end{example}

\begin{example}
มีซาลาเปา 4 ไส้ ต้องการซื้อ 10 ลูก โดยต้องซื้อแต่ละไส้อย่างน้อย 1 ลูก แต่ไส้หมูสับขออย่างน้อย 2 ลูก จะสามารถทำได้กี่วิธี

ปัญหานี้ก็ยังคงคล้ายคลึงกับตัวอย่างต่างๆ ก่อนหน้านี้อยู่ดี โดยแทนที่เราจะซื้อซาลาเปาทุกไส้มาตุนก่อน 1 ลูก ก็ซื้อเพียงไส้หมูสับมาก่อน 1 ลูก ทำให้เราเหลือซาลาเปาที่ยังต้องซื้อทั้งหมด 9 ลูก โดยต้องซื้อแต่ละไส้อย่างน้อย 1 ลูก ซึ่งสามารถทำได้ $\binom{8}{3}$ วิธี
\end{example}

\begin{example}
มีขนม 10 ชิ้น ต้องการแจกให้คน 4 คนจนหมด แต่อาจจะมีคนที่ไม่ได้สักชิ้นเลยก็ได้ จะสามารถทำได้กี่วิธี

ปัญหานี้ยังคงคล้ายกับก่อนหน้านี้ แต่วิธีการคิดอาจจะไม่เป็นธรรมชาติสักเล็กน้อย \enskip ก่อนอื่น สมมุติว่าเรามีขนมทั้งหมด 14 ชิ้น \enskip หากเราแจกขนมทั้ง 14 ชิ้นนี้ให้ทั้ง 4 คน โดยที่แต่ละคนได้อย่างน้อย 1 ชิ้น แล้วยึดขนมคืนมาจากแต่ละคน คนละ 1 ชิ้น จะได้ว่า เบ็ดเสร็จแล้ว เราได้แจกขนมไปทั้งสิ้น 10 ชิ้น โดยที่อาจจะมีคนที่ไม่ได้ขนมสักชิ้นเลยก็ได้ \enskip กล่าวอีกนัยหนึ่ง เราสามารถใช้ reduction แปลงปัญหาข้างต้นให้เป็นปัญหาการแจกขนม 14 ชิ้นให้คน 4 คนจนหมด โดยที่แต่ละคนต้องได้อย่างน้อย 1 ชิ้น ซึ่งสามารถทำได้ $\binom{13}{3}$ วิธี
\end{example}

\begin{example}
มีโดนัทให้เลือก 4 รส ต้องการซื้อ 10 ชิ้น แต่อาจจะไม่ครบทุกรสก็ได้ จะสามารถทำได้กี่วิธี

จะเห็นว่า ปัญหานี้คล้ายคลึงกับปัญหาในข้อที่แล้ว โดยเราสามารถทำการซื้อโดนัทมาก่อน 14 ชิ้น รสละอย่างน้อย 1 ชิ้น แล้วคืนรสละ 1 ชิ้นกลับไปให้ร้าน ซึ่งเบ็ดเสร็จแล้วเราจะซื้อโดนัทมาทั้งสิ้น 10 ชิ้น แต่อาจจะมีรสที่ไม่ได้ซื้อเลยก็ได้ \enskip กระบวนการดังกล่าวสามารถทำได้ $\binom{13}{3}$ วิธีที่แตกต่างกัน
\end{example}

\begin{example}\label{ex:stars-bars-donuts-first}
มีโดนัทให้เลือก 3 รส ต้องการซื้อ 10 ชิ้น โดยไม่ต้องครบทุกรสก็ได้ แต่รสแรกขออย่างน้อย 1 ชิ้น จะสามารถทำได้กี่วิธี

จะเห็นว่า ปัญหานี้ยังคงคล้ายคลึงกับตัวอย่างที่ผ่านๆ มาหลายๆ ตัวอย่าง แต่นำตัวอย่างเหล่านั้นมาผสมผสานกัน \enskip เริ่มแรก ให้เราซื้อโดนัทรสแรกมาก่อน 1 ชิ้น \enskip จากนั้น เราต้องซื้อโดนัท 9 ลูก โดยไม่ต้องครบทุกรสก็ได้ ซึ่งเทียบเท่ากับการซื้อโดนัทมาก่อน 12 ชิ้น รสละอย่างน้อย 1 ชิ้น แล้วคืนร้านไปรสละ 1 ชิ้น ซึ่งสามารถทำได้ $\binom{11}{2}$ วิธี

อีกแนวทางหนึ่งที่สามารถทำได้ คือการซื้อโดนัทมาก่อน 12 ชิ้น รสละอย่างน้อย 1 ชิ้น จากนั้น คืนสองรสหลังให้ร้านไปรสละ 1 ชิ้น ก็จะได้โดนัททั้งหมด 10 ชิ้น โดยที่รสแรกมีอย่างน้อย 1 ชิ้น \enskip จะเห็นว่า จำนวนวิะีการซื้อโดนัท 12 ชิ้น จากทั้งหมด 3 รสนั้นทำได้ $\binom{11}{2}$ วิธีเช่นกัน
\end{example}

\begin{example}
โปรแกรมต่อไปนี้จะพิมพ์ \str{*} ออกมาทางหน้าจอทั้งหมดกี่ตัว
\begin{lstlisting}[language=java]
for (int i = 1; i <= 10; i++)
  for (int j = 1; j <= i; j++)
    print("*")
\end{lstlisting}

จะเห็นว่า โปรแกรมนี้จะพิมพ์ \str{*} ออกมาหนึ่งตัว ในแต่ละค่าของคู่อันดับ $(\str{i},\str{j})$ ที่ทำให้ $1\leq \str{i}\leq \str{j}\leq 10$ \enskip กล่าวอีกนัยหนึ่ง จำนวน \str{*} ที่โปรแกรมจะพิมพ์ออกมา ก็คือจำนวนของคู่อันดับ $(\str{i},\str{j})$ โดยที่ $1\leq\str{i}\leq\str{j}\leq 10$ นั่นเอง \enskip เราจะหาจำนวนคู่อันดับดังกล่าวที่เป็นไปได้ได้อย่างไร

วิธีหนึ่งในการหาจำนวนคู่อันดับข้างต้น สามารถแปลงเป็นปัญหาการซื้อโดนัทใน Example~\ref{ex:stars-bars-donuts-first} ได้ดังนี้
\begin{itemize}[]
\item ให้ $\str{j}$ เป็นจำนวนโดนัทรสที่ 1 (จะเห็นว่า เนื่องจาก $\str{j}\geq 1$ แสดงว่าต้องมีโดนัทรสนี้อย่างน้อย 1 ชิ้น)
\item ให้ $\str{i}$ เป็นจำนวนโดนัทรสที่ 1 และ 2 รวมกัน (จะเห็นว่า หาก $\str{i}=\str{j}$ แสดงว่าไม่มีโดนัทรสที่ 2 เลย)
\item ให้ 10 เป็นจำนวนโดนัทรสที่ 1, 2, และ 3 รวมกัน (จะเห็นว่า หาก $\str{i}=10$ แสดงว่าไม่มีโดนัทรสที่ 3 เลย)
\end{itemize}
ตัวอย่างเช่น หาก $\str{i}=\str{j}=10$ แสดงว่ามีโดนัทรสแรก 10 ชิ้น และไม่มีรสที่ 2 และ 3 เลย

ดังนั้น จำนวน \str{*} ที่โปรแกรมจะพิมพ์ออกมา กล่าวคือ จำนวนของคู่อันดับ $(\str{i},\str{j})$ ทั้งหมดที่เป็นไปได้ที่สอดคล้องกับเงื่อนไข $1\leq\str{j}\leq\str{i}\leq 10$ ก็คือจำนวนวิธีการซื้อโดนัท 10 ชิ้นจากทั้งหมด 3 รส โดยรสแรกมีอย่างน้อย 1 ชิ้น แต่รสที่เหลืออาจจะไม่ซื้อเลยก็ได้ ซึ่งมีทั้งหมด $\binom{11}{2}$ วิธี \enskip ดังนั้น โปรแกรมนี้จะพิมพ์ \str{*} ออกมาทั้งหมด $\binom{11}{2}=\frac{11\cdot 10}{2\cdot 1}=55$ ตัว
\end{example}

เราสามารถใช้วิธีการคิดดังกล่าวให้เหตุผลกับโปรแกรมในลักษณะเดียวกันแต่ซับซ้อนกว่าได้
\begin{example}\label{ex:loop3-combi-proof}
ค่าของตัวแปร \str{count} ในส่วนของโปรแกรมต่อไปนี้จะเป็นเท่าใดเมื่อโปรแกรมสิ้นสุดการทำงาน โดยที่ \str{n} เป็นตัวแปรที่ผู้ใช้กำหนดค่ามาให้ก่อนที่ส่วนของโปรแกรมนี้จะทำงาน
\begin{lstlisting}[language=java]
int count = 0;
for (int i = 1; i <= n; i++)
  for (int j = 1; j <= i; j++)
    for (int k = 1; k <= j; k++)
      count++;
\end{lstlisting}

เนื่องจาก \str{count} จะนับเพิ่มขึ้น 1 ในแต่ละค่าของลำดับ $(\str{i},\str{j},\str{k})$ ที่เป็นไปได้ จะเห็นว่า ค่าสุดท้ายของ \str{count} คือจำนวนของลำดับ $(\str{i},\str{j},\str{k})$ ที่สอดคล้องกับเงื่อนไข $1\leq\str{k}\leq\str{j}\leq\str{i}\leq\str{n}$ \enskip การหาจำนวนลำดับดังกล่าว สามารถทำได้สองวิธี ดังนี้
\begin{enumerate}[]
\item {\bf พิจารณา loop \str{i}--\str{j}--\str{k} ทั้งสามชั้น}: หากใช้เหตุผลในทำนองเดียวกันกับตัวอย่างที่แล้ว จะเห็นว่า จำนวนลำดับ $(\str{i},\str{j},\str{k})$ ที่เป็นไปได้ ก็คือจำนวนวิธีซื้อของ 4 ชนิด รวม $\str{n}$ ชิ้น โดยที่ชนิดแรกต้องซื้ออย่างน้อย 1 ชิ้น แต่ชนิดที่เหลืออาจจะไม่ซื้อเลยก็ได้

กระบวนการดังกล่าวเทียบเท่ากับการซื้อของมา $\str{n}+3$ ชิ้น ชนิดละอย่างน้อย 1 ชิ้น แล้วคืนของทุกชนิดยกเว้นชนิดแรกให้ร้านไปชนิดละ 1 ชิ้น ซึ่งสามารถทำได้ $\binom{\str{n}-2}{3}$ วิธี \enskip ดังนั้น ค่าของ $\str{count}$ จึงเป็น $\binom{\str{n}-2}{3}$ หลังจากส่วนของโปรแกรมข้างต้นจบการทำงาน

\item {\bf พิจารณาเฉพาะ loop \str{j}--\str{k} สองชั้นใน}: เราสามารถใช้เหตุผลในลักษณะเดียวกับตัวอย่างที่แล้วได้เช่นกัน กล่าวคือ ในแต่ละค่าของ \str{i} นั้น loop สองชั้นในจะทำงานทั้งหมดกี่ครั้ง (ซึ่งก็คือจำนวนครั้งที่ตัวแปร \str{count} นั้นถูกนับเพิ่มในแต่ละครั้งที่ loop นอกสุดทำงาน) \enskip จะเห็นว่า ในแต่ละค่าของ \str{i} นั้น loop สองชั้นในจะทำงานเท่ากับจำนวนของคู่อันดับ $(\str{j},\str{k})$ ที่สอดคล้องกับเงือนไข $1\leq\str{k}\leq\str{j}\leq\str{i}$ ซึ่งตรงกับจำนวนวิธีซื้อของ 3 ชนิด รวม $\str{i}$ ชิ้น โดยชนิดแรกต้องซื้ออย่างน้อย 1 ชิ้น แต่ชนิดที่เหลืออาจจะไม่ซื้อเลยก็ได้ \enskip กระบวนการดังกล่าวเทียบเท่ากับการซื้อของมา $\str{i}+2$ ชิ้น ชนิดละอย่างน้อย 1 ชิ้น แล้วคืนของทุกชนิดยกเว้นชนิดแรกให้ร้านไปชนิดละ 1 ชิ้น ซึ่งสามารถทำได้ $\binom{\str{i}+1}{2}$ วิธี

ดังนั้น ในแต่ละค่าของ \str{i} นั้น ตัวแปร \str{count} จะถูกนับเพิ่มทั้งหมด $\binom{\str{i}+1}{2}$ ครั้ง \enskip แต่เนื่องจาก \str{i} มีค่าได้ตั้งแต่ $1,2,\ldots,\str{n}$ แสดงว่าตัวแปร \str{count} จะถูกนับเพิ่มทั้งหมด $\sum_{\str{i}=1}^{\str{n}}{\binom{\str{i}+1}{2}}$ ครั้ง กล่าวคือ ค่าสุดท้ายของ \str{count} เมื่อส่วนของโปรแกรมข้างต้นจบการทำงานคือ \[\sum_{\str{i}=1}^{\str{n}}{\binom{\str{i}+1}{2}}\]
\end{enumerate}
จากข้างต้น เราสามารถหาค่าของตัวแปร \str{count} หลังส่วนของโปรแกรมจบการทำงานได้สองวิธี ่แม้ว่าทั้งสองวิธีจะให้คำตอบที่หน้าตาไม่เหมือนกัน แต่ก็เป็นค่าสุดท้ายของ \str{count} เช่นกัน จึงสรุปได้ว่า ทั้งสองคำตอบข้างต้นนั้นต้องเท่ากัน กล่าวคือ 
\[\sum_{\str{i}=1}^{\str{n}}{\binom{\str{i}+1}{2}}=\binom{\str{n}+2}{3}\]
วิธีการหาคำตอบโดยให้เหตุผลสองวิธี ดังที่ได้สาธิตข้างต้น เป็นวิธีการพิสูจน์วิธีการหนึ่งที่เรียกว่า \emph{combinatorial proof} ดังที่จะได้กล่าวโดยละเอียดในลำดับถัดไป

ก่อนอื่น เราสามารถจัดรูปสมการข้างต้นได้ โดยใช้สูตรของ binomial coefficient $\binom{n}{k}=\frac{n!}{(n-k)!k!}$ และสูตรผลรวม $\sum_{i=1}^{n}{i}=\frac{n(n+1)}{2}$ ดังนี้
\begin{align*}
\sum_{i=1}^{n}{\binom{\str{i}+1}{2}} &= \binom{n+2}{3} \\
\sum_{i=1}^{n}{\frac{(i+1)i}{2}} &= \binom{n+2}{3} \\
\sum_{i=1}^{n}{i^2+i} &= 2\binom{n+2}{3} \\
\sum_{i=1}^{n}{i^2}+\sum_{i=1}^{n}{i} &= 2\frac{(n+2)(n+1)n}{3\cdot 2} \\
\sum_{i=1}^{n}{i^2} &= \frac{(n+2)(n+1)n}{3}-\sum_{i=1}^{n}{i} \\
&= \frac{(n+2)(n+1)n}{3}-\frac{n(n+1)}{2} \\
&= n(n+1)\left[\frac{n+2}{3}-\frac{1}{2}\right] \\
&= n(n+1)\left[\frac{2(n+2)-3}{6}\right] \\
&= n(n+1)\left[\frac{2n+4-3}{6}\right] \\
\sum_{i=1}^{n}{i^2} &= \frac{n(n+1)(2n+1)}{6}
\end{align*}
จะเห็นว่า เราสามารถใช้ combinatorial proof เป็นเครื่องมือในการหาสูตรปิดของผลรวมได้
\end{example}
